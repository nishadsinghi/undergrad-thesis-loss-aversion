import sys
import os
DIRNAME = os.path.dirname(__file__)
sys.path.append(os.path.join(DIRNAME, "..", "..", "..", "src"))

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import seaborn as sns
from scipy.stats import skew, chisquare
import matplotlib

from LCA import PrepareRecurrentWeights, RunLCASimulation, GetValueInputZeroReference
from LUT import prepareStdNormalLUT, SampleFromLUT



QUANTILES = [0.1, 0.3, 0.5, 0.7, 0.9]
MARKERS = ['o', 's', 'D', 'v', '^']
COLORS = ['tab:blue', 'tab:orange', 'tab:green', 'tab:red', 'tab:purple']

sns.set(font_scale=1.5)
fig = plt.figure(figsize=(20, 40))
# fig.suptitle("Fits for data generated by LCA with \nUnequal Attention - Dataset 1")
# matplotlib.rcParams.update({'font.size': 14})

def plotQPF(ax, dataWithRatios, plotType, linestyle, label):
    sortedDataWithRatios = dataWithRatios[dataWithRatios[:,-1].argsort()]
    split = np.array_split(sortedDataWithRatios, 8, axis=0)

    for quantile, marker, color in zip(QUANTILES, MARKERS, COLORS):
        def computeQuantiles(data):
            reactionTimes = data[:, 1].flatten()
            reactionTimeForQuantile = np.quantile(reactionTimes, quantile)
            return reactionTimeForQuantile

        def computeP(data):
            choices = data[:, 0].flatten()
            P_mean = np.mean(choices)
            return P_mean

        toPlotX = [computeP(_) for _ in split]
        toPlotY = [computeQuantiles(_) for _ in split]

        if plotType == 'plot':
            ax.plot(toPlotX, toPlotY, color=color, linestyle=linestyle, label=label)
        elif plotType == 'scatter':
            ax.scatter(toPlotX, toPlotY, marker=marker, color=color)

        ax.set_ylabel("RT Quantiles (s)")#, fontsize=16)
        ax.set_xlabel("P(accept)")#, fontsize=16)
        ax.set_ylim(0, 3.1)
        ax.set_xlim(0, 1)


data = np.genfromtxt("unequalThresholdSimulatedData.csv", delimiter=',')
allStakes = np.unique(data[:, -2:], axis=0)
computeRatio = lambda trial: -1*data[trial, 2]/data[trial, 3]
allRatios = [computeRatio(trial) for trial in range(np.shape(data)[0])]
dataWithRatios = np.hstack((data[:, 0:2], np.reshape(allRatios, (-1, 1))))

    # LCA
def filterFunction(tup):
    if tup[-1] != -1:
        return True
    else:
        return False

numSimulationsPerCondition = 200

def generateModelData(lcaWrapper, parameters):
    allModelData = np.zeros(3)
    for stakes in allStakes:
        gainValue, lossValue = stakes
        gainLossRatio = -1 * gainValue / lossValue
        print("Ratio: ", gainLossRatio)
        allSimulations = [lcaWrapper(gainValue, lossValue, *parameters) for _ in
                          range(numSimulationsPerCondition)]
        allValidResponseSimulations = list(filter(filterFunction, allSimulations))
        numValidResponses = len(allValidResponseSimulations)
        allActivations, allModelRTs, allModelResponses = zip(*allValidResponseSimulations)
        modelStakes = np.full((numValidResponses, 1), gainLossRatio)
        modelDataForStakes = np.hstack(
            (np.array(allModelResponses).reshape(-1, 1), np.array(allModelRTs).reshape(-1, 1), modelStakes))
        allModelData = np.vstack((allModelData, modelDataForStakes))

    allModelData = allModelData[1:, :]
    return allModelData


# set up look-up table (LUT)
LUTInterval = 0.0001
numAccumulators = 2
stdNormalLUT = prepareStdNormalLUT(LUTInterval)
sampleFromLUT = SampleFromLUT(stdNormalLUT)
sampleFromZeroMeanLUT = lambda stdDev: sampleFromLUT(0, stdDev, numAccumulators)

# set-up the LCA
identityUtilityFunction = lambda x: x
getValueInput = GetValueInputZeroReference(identityUtilityFunction)

maxTimeSteps = 750
deltaT = 0.02
prepareRecurrentWeights = PrepareRecurrentWeights(numAccumulators)
lca = RunLCASimulation(getValueInput, sampleFromZeroMeanLUT, prepareRecurrentWeights, maxTimeSteps, deltaT)


# ONLY LOSS AVERSION
def getStartingActivation(startingBias, threshold):
    if startingBias < 0:
        return [-1 * startingBias * threshold, 0]
    else:
        return [0, startingBias * threshold]


getChoiceAttributes = lambda gain, loss: np.array([[0, 0], [gain, loss]])
getAllThresholds = lambda threshold: [threshold] * numAccumulators
attributeProbabilities = [0.5, 0.5]

lcaWrapper = lambda gain, loss, decay, competition, noiseStdDev, nonDecisionTime, threshold, constantInput, lossWeight: \
    lca(attributeProbabilities, getChoiceAttributes(gain, lossWeight * loss), getStartingActivation(0, threshold),
        decay, competition, constantInput,
        noiseStdDev, nonDecisionTime, getAllThresholds(threshold))

params = [ 1.26651102,  1.38550771, 33.80923627,  0.,         23.3004681,  51.07854623, 2.06278608]

modelSimulationData = generateModelData(lcaWrapper, params)

ax1 = plt.subplot2grid(shape=(1,3), loc=(0,0), colspan=1)
plotQPF(ax1, dataWithRatios, 'scatter', '-', 'Empirical data')
plotQPF(ax1, modelSimulationData, 'plot', '--', 'LCA')
ax1.set_title("Loss Aversion\n$\chi^2 = 36.7$")
ax1.set_aspect(0.25)


# ONLY STARTING BIAS
lcaWrapper = lambda gain, loss, decay, competition, noiseStdDev, nonDecisionTime, threshold, constantInput, startingBias: \
    lca(attributeProbabilities, getChoiceAttributes(gain, loss), getStartingActivation(startingBias, threshold), decay,
        competition, constantInput,
        noiseStdDev, nonDecisionTime, getAllThresholds(threshold))

params = [ 2.92738005,  2.47215217, 13.96825639,  0.2403411,  12.15063253, 56.09786443, -0.21203486]

modelSimulationData = generateModelData(lcaWrapper, params)
ax2 = plt.subplot2grid(shape=(1,3), loc=(0,1), colspan=1)
plotQPF(ax2, dataWithRatios, 'scatter', '-', 'Empirical data')
plotQPF(ax2, modelSimulationData, 'plot', '--', 'LCA')
ax2.set_title("Predecisional bias\n$\chi^2 = 21.5$")
ax2.set_aspect(0.25)


# ONLY FIXED UTILITY BIAS
lcaWrapper = lambda gain, loss, decay, competition, noiseStdDev, nonDecisionTime, threshold, constantInput1, constantInput2: \
        lca(attributeProbabilities, getChoiceAttributes(gain, loss), getStartingActivation(0, threshold), decay, competition, (constantInput1, constantInput2),
            noiseStdDev, nonDecisionTime, getAllThresholds(threshold))

params = [ 1.88847536,  1.07847604, 19.97505331,  0.17864825,  8.29629855, 19.46238196, 17.45262187]
modelSimulationData = generateModelData(lcaWrapper, params)
ax3 = plt.subplot2grid(shape=(1,3), loc=(0,2), colspan=1)
plotQPF(ax3, dataWithRatios, 'scatter', '-', 'Empirical data')
plotQPF(ax3, modelSimulationData, 'plot', '--', 'LCA')
ax3.set_title("Fixed Utility bias\n$\chi^2 = 29.5$")
ax3.set_aspect(0.25)

# plt.legend()
fig.tight_layout()#rect=[0, 0.03, 1, 0.95])
plt.savefig("QPF.png", bbox_inches='tight')
plt.close()
